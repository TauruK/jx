1.部署thinkPHP到项目目录
2.开启重写模式
	1)在apache 的httpd.conf中开启mod_rewrite.so模块
	2)在[项目根目录]/Public/找到.htaccess文件 在index.php后边加”?”号
3.在httpd-vhosts.conf 虚拟机配置中项中加入 AllowOverride All---表示允许访问重写规则，重启apache

//--------------------路由配置---------------------------------------
/************rule分组批量路由注册(推荐用这种)***********************/
Route::group('index',function(){
	Route::rule([
		
		'/index/index' => 'index/index/index',
		'/index/aa/:id/:name' => 'index/index/aa'
	
	]);
});

/**********************各种路由演示**********************************/
//路由定义
use \think\Route;
/**********rule单条路由注册***************/
/*Route::rule('/','index/index/index');
Route::rule('index/test','index/test/index');*/

/************rule批量(多条)路由注册***************/
/*Route::rule([

	'/' => 'index/index/index',
	'index/test' => 'index/test/index',
	'index/index/aa' => 'index/index/aa',
	'admin/test/test/[:id]' => 'admin/test/test'

]);*/

/************rule分组路由注册(推荐)***********************/
/*Route::group('index',function(){
	
	Route::rule('/index/index','index/index/index');
	Route::rule('/index/aa/:id/:name','index/index/aa');
	Route::rule('/test','index/test/index');
	
});
Route::group('admin',function(){
	
	Route::rule('/test/test','admin/test/test');
	
});*/
/************rule分组批量路由注册(推荐)***********************/
Route::group('index',function(){
	Route::rule([
		
		'/index/index' => 'index/index/index',
		'/index/aa/:id/:name' => 'index/index/aa'
	
	]);
});

/************************验证表单步骤*********************/
1.判断是否是POST请求(表单提交)
2.接收POST数据
3.验证POST数据
	使用TP验证器验证数据,并过滤数据
	1)先设置验证规则
	2)定义错误信息
	3)实例化Validate类
	4)调用Validate实例的check方法进行验证
	5)判断验证结果
	6)如果验证不通过调用Validate实例的getError方法获取错误信息并显示
4.调用模型判断数据与数据库的数据是否匹配
5.根据匹配结果做相应处理
/**************************一种更简单的操作流程步骤(推荐)*******************/
一种更简单的操作流程步骤就是使用TP5的验证器
1.判断请求类型
2.接收请求数据
3.使用验证器验证请求数据
4.操作数据新增或更新入库
------操作入库前操作：执行这步操作时还可以判断是否要对请求数据进行处理，如果要就要在新增或更新事件前做相应处理（这个操作常用）
------操作入库后操作：执行完新增或更新数据入库后还可以触发执行一个事件后处理，这个操作一般比较少用

/***********技巧记录*******************/
【后台权限设计】：
RBAC--------一般最少需要三张表来实现：用户表---->角色表------>权限表
1.每个用户可以对应一个角色如：超级管理员     关系为：一对多
2.每个角色对应多个权限：如普通管理员只有用户管理和商品管理的权限，权限管理及订单管理这些权限是没有的，关系为：一对多
简单权限的实现思路：
1.当用户登录后，取得用户信息，判断这个用户对应的是什么角色
2.通过角色id，在权限表里查询出这个角色对应的所有权限，每一个权限一般是由两个字段控制，
--取得这两个字段的值后需要将他们组合成一个有【固定格式的字符串】的形式如：【控制器名/方法名】这就代表了一个权限
3.将这些有固定格式的字符串权限用个空数组保存起来（就是在次组成一个数组）这个用户的所有权限都在这个数组里了，然后将这个数组存进session
4.在公共控制器里的初始化方法里（在这个控制器里实现了基类控制器的初始化方法，其他控制器继承了这个控制器）获取用户当前访问的控制器名和方法名
--也是将其组合成一个有【固定格式的字符串形式】如：【控制器名/方法名】，然后将其与保存在session里的权限数组匹配，如果这个字符串在这个数组
--里有找到，就代表有权限，如果没有找到就提示没有权限
5.注意点，这里需要对index控制器，也就是所有首页相关页，还有超级管理员放行，超级管理员的权限一般就只有一个字符*
--需要用另外一个session保存，每次请求时先判断用户访问的是否是index控制器，或是否是*超级管理员，如果是则返回函数不执行下面的判断
--如果不是则进行第4步权限数组的判断
6.还有一点权限菜单是动态生成的，也就是不同角色的用户能显示的权限菜单是不一样的，这个也是需要根据session权限数组里的权限来生成这个菜单

【奇营技巧】
使用场景：
1、数据表的数据具有层级（父子）关系（如分类表、权限表,有字段指向父级id如：pid）
2、数据在模板中展示也具有层级关系。如：前台商品分类展示这种类型的就可以用这个技巧，
--前台多层次导航栏展示也可以用这个技巧，还有很多应用都可以用这个技巧，后台权限分配展示

技巧使用步骤
1：以二维数组中的每个元素的主键字段值作为其相应下标。
2：以指向父字段值（如pid字段）进行分组，即把具有相同的pid值分为同一组。

【SQL中的两个常用函数】
	FIND_IN_SET(str,strlist):查询出子串str，是否在由逗号分隔的目标字符串strlist中存在
	group_concat(表字段)主要根据某个字段进行分组，把相同字段的值连接在一起。默认连接符号是逗号 ，如果用|连接则：
	语法:group_concat(字段名 SEPARATOR “|”)
	
【商品表设计】	
一般简单的需要5张表来实现：商品表，类型表，类型属性表，商品属性表，分类表
1.首先我们要分析一个商品的属性类型及其一些基础通用信息
---商品的基础信息（表）：无论什么商品必须会有，品名，图片，价格，库存，【分类】，【类型】，【商品属性】
---还会有些可选信息，如：是否上架，是否新品，是否精品，是否推荐，是否热卖等
2.其中上面的【分类】，【类型】，【商品属性】分别都是一张表，每一类型又都有其的一些共同属性，叫【类型属性】
--其中【类型属性】又是一张表，而这【类型属性表】的值是保存在【商品属性表】里的，也就是类型属性是保存的是
--某一种类型商品属性的名字，而具体的值是保存在商品属性表里的，因为同一类型的不同商品的属性的具体值是不一样的，
--也就是说同一类产品不同的属性值是不同的商品，产品+具体属性值=商品
表关系：
每个商品对应一个类型(一对一)，对应一个分类(一对一)，对应多个商品属性(一对多)
每个类型对应多个属性(一对多)，每个类型属性对应一条具体的属性值(一对一)

/******************************************************************************************************/
【找分类的两种方式】:
1.找祖先分类：传递当前分类的pid,进行递归查找。（判断谁的cat_id等于我的pid,则找到祖先）
2.找子孙分类：传递当前分类的cat_id,进行递归查找。(判断谁的pid等于我的cat_id,则找到子孙)

注：【面包宵导航】就是找分类的祖先分类，使用的是第一种方式

【商品浏览历史记录实现方法】：
	1.记录用户第次访问商品详情页时，记录此商品id将其存入cookie中并设置有效期为七天，一般历史记录有效期为七天
	2.然后从cookie中取出记录的商品id查出商品，这里查数据时需要使用到SQL的一函数【FIELD函数】这是一个SQL函数
	
/******************************************购物车功能**********************************************************/
【购物车功能】

说明：购物车分两种，一种京东的cookie+mysql可离线购物车，一种是淘宝的mysql不可离线购物车，这两种购物车各有优缺点;

这里我们来讲下淘宝的购物车是怎样实现

1.先给购物个单独建个购物车类或模型类这里

购物车类

属性：

	$cartData = []     这个类属性是用于保存购物临时数据的数组，我们的购物车数据在没入库前操作的都是这个数组

方法：

	1.构造方法，用于实例化购物车类时初始化$cartData数组，从数据库中获取当前登录用户的购物车数据，在按一定格式组合存入此数组中

	2.add方法，商品加入购物车方法

	3.getCartGoods方法，根据临时数组里保存的购物车数据到数据库中连表查询商品详情与商品属性等信息，然后将数据重新组合成一个特定的数组，利于前台模版展示的数组

	4.inc方法，购物车商品+数量

	5.dec方法，购物车商品-数量

	6.inputNum方法，购物车商品直接输入数量

	7.del方法，购物车商品删除

	8.clearCatr方法，清空购物车所有商品

步骤：

一、商品加入购物车

前端：

1.点击加入购物车，获取商品id,商品单选属性，商品数量，构建参数，使用ajax发送服务器

服务器：

1.判断是否是用户是否登录

2.判断是否为ajax请求

3.接收ajax请求的数据

4.实例化购物车类，调用购物车add方法向数据库购物车表中添加商品

add方法里的判断

	1）判断用户购物车是否为空

	2）此商品在购物车里是否有相同的，相同的则执行字段更新操作（商品数量增加操作）

	3）购物车为空或没有相同商品，则执行新增操作（将商品数据插入购物车表）

二、在用户购物结算页里展示商品（重难点）

服务器端：

1.判断用户是否登录

2.实例化购物车类，调用getCartGoods方法，购物车商品获取并重构模版展示数组方法

getCartGoods方法里的操作

	1）根据用户id到数据库连表查询购物车里的数据，并定义一个空数组用于重构数组，将重构后的数组返回

	下面演示怎么重构这个数组及SQL如何查询（需要使用GROUP_CONCAT函数）

    //构建用于模板显示的数组
    			$data[]=[
    				'goods_id' => $goods_id,
    				'goods_attr_ids' => $goods_attr_ids,
    				'goods_number' => $goods_number,
    				'goodsInfo' => Db::name('goods')->where('goods_id',$goods_id)->find(),
    				'attr'=> Db::name('goods_attr')
    							->alias('t1')
    							->field("GROUP_CONCAT(t2.attr_name,':',t1.attr_value Separator '<br />') attr_info,
    									sum(t1.attr_price) attr_total_price")
    							->join('jx_attribute t2','t1.attr_id=t2.attr_id','left')
    							->where('t1.goods_id',$goods_id)
    							->where(['t1.goods_attr_id'=>['in',$goods_attr_ids]])
    							->find()
    			];

3.接收到重构后的购物车商品数据后分配到模版变量，并在前端展示

三、购物车商品数量的增减功能

前端：

1.点击+或-时构建商品参数给服务器发送相应的ajax请求

服务器端：

1.判断用户是否登录

2.判断是否为ajax请求

3.接收参数

4.实例化购物车类，调用购物车inc或dec方法，这两方法功能基本一样，只是一个是做数量的自增一个是做数量的自减

inc与dec方法里的操作

	1）更新购物车表商品数量字段的自增1或自减1

四、用户在购物车结算页直接输入商品数量的处理

前端：

1.构建相应参数通过ajax发送给服务器处理

服务器端：

1.判断是否登录

2.判断是否为ajax请求

3.接收参数

4.实例化购物车类，调用inputNum方法，用户直接输入商品数量的处理

inputNum方法里的操作

1）根据参数构建数据库更新条件，更新购物车表里的商品数量字段

五、购物车商品的删除与清空所有商品

前端：

1.删除商品ajax请求需要协带参数，清空所有商品ajax请求不需要协带参数（因为清空只要删除当前登录用户购物车里的所有数据即可，在后台里可以获取用户的id）

服务器端：

删除：

1.判断用户是否登录

2.判断是否为ajax请求

3.接收参数

4.实例化购物车类，调用del方法，购物车商品删除

del方法里的操作

	1）根据参数从数据库中删除指定的商品

清空：

	1.判断用户是否登录

	2.判断是否为ajax请求

	3.实例化购物车类，调用clearCatr方法，清空购物车数据

	clearCatr方法里的操作

	根据当前登录用户的id从数据库中删除所有商品记录










