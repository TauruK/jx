1.部署thinkPHP到项目目录
2.开启重写模式
	1)在apache 的httpd.conf中开启mod_rewrite.so模块
	2)在[项目根目录]/Public/找到.htaccess文件 在index.php后边加”?”号
3.在httpd-vhosts.conf 虚拟机配置中项中加入 AllowOverride All---表示允许访问重写规则，重启apache

//--------------------路由配置---------------------------------------
/************rule分组批量路由注册(推荐用这种)***********************/
Route::group('index',function(){
	Route::rule([
		
		'/index/index' => 'index/index/index',
		'/index/aa/:id/:name' => 'index/index/aa'
	
	]);
});

/**********************各种路由演示**********************************/
//路由定义
use \think\Route;
/**********rule单条路由注册***************/
/*Route::rule('/','index/index/index');
Route::rule('index/test','index/test/index');*/

/************rule批量(多条)路由注册***************/
/*Route::rule([

	'/' => 'index/index/index',
	'index/test' => 'index/test/index',
	'index/index/aa' => 'index/index/aa',
	'admin/test/test/[:id]' => 'admin/test/test'

]);*/

/************rule分组路由注册***********************/
/*Route::group('index',function(){
	
	Route::rule('/index/index','index/index/index');
	Route::rule('/index/aa/:id/:name','index/index/aa');
	Route::rule('/test','index/test/index');
	
});
Route::group('admin',function(){
	
	Route::rule('/test/test','admin/test/test');
	
});*/
/************rule分组批量路由注册(推荐用这种)***********************/
Route::group('index',function(){
	Route::rule([
		
		'/index/index' => 'index/index/index',
		'/index/aa/:id/:name' => 'index/index/aa'
	
	]);
});

/************************验证表单步骤*********************/
1.判断是否是POST请求(表单提交)
2.接收POST数据
3.验证POST数据
	使用TP验证器验证数据,并过滤数据
	1)先设置验证规则
	2)定义错误信息
	3)实例化Validate类
	4)调用Validate实例的check方法进行验证
	5)判断验证结果
	6)如果验证不通过调用Validate实例的getError方法获取错误信息并显示
4.调用模型判断数据与数据库的数据是否匹配
5.根据匹配结果做相应处理
/**************************一种更简单的操作流程步骤(推荐)*******************/
一种更简单的操作流程步骤就是使用TP5的验证器
1.判断请求类型
2.接收请求数据
3.使用验证器验证请求数据
4.操作数据新增或更新入库
------操作入库前操作：执行这步操作时还可以判断是否要对请求数据进行处理，如果要就要在新增或更新事件前做相应处理（这个操作常用）
------操作入库后操作：执行完新增或更新数据入库后还可以触发执行一个事件后处理，这个操作一般比较少用

/***********技巧记录*******************/
【后台权限设计】：
RBAC--------一般最少需要三张表来实现：用户表---->角色表------>权限表
1.每个用户可以对应一个角色如：超级管理员     关系为：一对多
2.每个角色对应多个权限：如普通管理员只有用户管理和商品管理的权限，权限管理及订单管理这些权限是没有的，关系为：一对多
简单权限的实现思路：
1.当用户登录后，取得用户信息，判断这个用户对应的是什么角色
2.通过角色id，在权限表里查询出这个角色对应的所有权限，每一个权限一般是由两个字段控制，
--取得这两个字段的值后需要将他们组合成一个有【固定格式的字符串】的形式如：【控制器名/方法名】这就代表了一个权限
3.将这些有固定格式的字符串权限用个空数组保存起来（就是在次组成一个数组）这个用户的所有权限都在这个数组里了，然后将这个数组存进session
4.在公共控制器里的初始化方法里（在这个控制器里实现了基类控制器的初始化方法，其他控制器继承了这个控制器）获取用户当前访问的控制器名和方法名
--也是将其组合成一个有【固定格式的字符串形式】如：【控制器名/方法名】，然后将其与保存在session里的权限数组匹配，如果这个字符串在这个数组
--里有找到，就代表有权限，如果没有找到就提示没有权限
5.注意点，这里需要对index控制器，也就是所有首页相关页，还有超级管理员放行，超级管理员的权限一般就只有一个字符*
--需要用另外一个session保存，每次请求时先判断用户访问的是否是index控制器，或是否是*超级管理员，如果是则返回函数不执行下面的判断
--如果不是则进行第4步权限数组的判断
6.还有一点权限菜单是动态生成的，也就是不同角色的用户能显示的权限菜单是不一样的，这个也是需要根据session权限数组里的权限来生成这个菜单

【奇营技巧】
使用场景：
1、数据表的数据具有层级（父子）关系（如分类表、权限表,有字段指向父级id如：pid）
2、数据在模板中展示也具有层级关系。如：前台商品分类展示这种类型的就可以用这个技巧，
--前台多层次导航栏展示也可以用这个技巧，还有很多应用都可以用这个技巧，后台权限分配展示

技巧使用步骤
1：以二维数组中的每个元素的主键字段值作为其相应下标。
2：以指向父字段值（如pid字段）进行分组，即把具有相同的pid值分为同一组。

【SQL中的两个常用函数】
	FIND_IN_SET(str,strlist):查询出子串str，是否在由逗号分隔的目标字符串strlist中存在
	group_concat(表字段)主要根据某个字段进行分组，把相同字段的值连接在一起。默认连接符号是逗号 ，如果用|连接则：
	语法:group_concat(字段名 SEPARATOR “|”)
	
【商品表设计】	
一般简单的需要5张表来实现：商品表，类型表，类型属性表，商品属性表，分类表
1.首先我们要分析一个商品的属性类型及其一些基础通用信息
---商品的基础信息（表）：无论什么商品必须会有，品名，图片，价格，库存，【分类】，【类型】，【商品属性】
---还会有些可选信息，如：是否上架，是否新品，是否精品，是否推荐，是否热卖等
2.其中上面的【分类】，【类型】，【商品属性】分别都是一张表，每一类型又都有其的一些共同属性，叫【类型属性】
--其中【类型属性】又是一张表，而这【类型属性表】的值是保存在【商品属性表】里的，也就是类型属性是保存的是
--某一种类型商品属性的名字，而具体的值是保存在商品属性表里的，因为同一类型的不同商品的属性的具体值是不一样的，
--也就是说同一类产品不同的属性值是不同的商品，产品+具体属性值=商品
表关系：
每个商品对应一个类型(一对一)，对应一个分类(一对一)，对应多个商品属性(一对多)
每个类型对应多个属性(一对多)，每个类型属性对应一条具体的属性值(一对一)

/******************************************************************************************************/
【找分类的两种方式】:
1.找祖先分类：传递当前分类的pid,进行递归查找。（判断谁的cat_id等于我的pid,则找到祖先）
2.找子孙分类：传递当前分类的cat_id,进行递归查找。(判断谁的pid等于我的cat_id,则找到子孙)

注：【面包宵导航】就是找分类的祖先分类，使用的是第一种方式

【商品浏览历史记录实现方法】：
	1.记录用户第次访问商品详情页时，记录此商品id将其存入cookie中并设置有效期为七天，一般历史记录有效期为七天
	2.然后从cookie中取出记录的商品id查出商品，这里查数据时需要使用到SQL的一函数【FIELD函数】这是一个SQL函数











